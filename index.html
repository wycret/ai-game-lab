<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI æ¸¸æˆç›ˆåˆ©ç³»ç»Ÿ</title>
    <!-- å¼•å…¥ Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- å¼•å…¥ React å’Œ ReactDOM UMD ç‰ˆæœ¬ï¼Œç¡®ä¿å…¨å±€å˜é‡å¯ç”¨ -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

    <style>
        /* è®¾ç½®å…¨å±€å­—ä½“å’ŒèƒŒæ™¯ï¼Œå¢å¼ºè§†è§‰æ•ˆæœ */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* æ²‰ç¨³çš„æ·±è“è‰²èƒŒæ™¯ */
            color: #e2e8f0;
        }
        /* ç¡®ä¿è‡ªå®šä¹‰ alert æ ·å¼å¯ä»¥è¦†ç›– */
        .custom-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background: #1f2937;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: 80%;
            text-align: center;
        }
        /* è´ªåƒè›‡æ¸¸æˆåŒºåŸŸçš„ç‰¹æ®Šæ ·å¼ */
        .snake-board {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1 / 1; /* ä¿æŒæ­£æ–¹å½¢ */
            margin: 0 auto;
            background-color: #1e293b;
            border: 2px solid #475569;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3); /* éœ“è™¹æ•ˆæœ */
            display: grid;
            grid-template-columns: repeat(20, 1fr); /* 20x20 ç½‘æ ¼ */
        }

        .snake-segment {
            background-color: #38bdf8; /* è›‡èº«é¢œè‰² */
            border-radius: 2px;
            box-shadow: 0 0 5px #0ea5e9;
        }

        .food-item {
            background-color: #f87171; /* é£Ÿç‰©é¢œè‰² */
            border-radius: 50%;
            box-shadow: 0 0 8px #ef4444;
        }
    </style>
</head>
<body>
    <div id="root">
        <!-- React åº”ç”¨å°†åœ¨æ­¤å¤„æ¸²æŸ“ -->
    </div>

    <!-- è‡ªå®šä¹‰ Alert æ›¿ä»£æµè§ˆå™¨çš„ alert() -->
    <div id="custom-alert-container"></div>
    <script type="text/javascript">
        // Overrides the native alert() function to use a custom UI
        window.alert = function (message) {
            const container = document.getElementById('custom-alert-container');
            const alertBox = document.createElement('div');
            alertBox.className = 'custom-alert';
            alertBox.innerHTML = `
                    <p class="text-white text-lg mb-4">${message}</p>
                    <button
                        onclick="this.parentNode.remove()"
                        class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded transition duration-150"
                    >
                        ç¡®è®¤
                    </button>
                `;
            container.appendChild(alertBox);
        };
    </script>

    <!-- React code block - Pure JavaScript + createElement to avoid SyntaxError -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, onSnapshot, runTransaction } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        // Use React global variables (e is short for React.createElement)
        const { createElement: e, useState, useEffect, useContext, createContext, useCallback, useRef } = window.React;
        const { createRoot } = window.ReactDOM;

        // =================================================================
        // 1. CONFIGURATION AND INITIALIZATION
        // =================================================================

        // 1.1 App ID (Mandatory for Firestore path isolation)
        const appId = 'AiGameWeb';

        // 1.2 Firebase Configuration (Injected via global variables or User's config)
        let firebaseConfig = null;
        // æ£€æŸ¥æ˜¯å¦åœ¨ Canvas ç¯å¢ƒä¸­è¿è¡Œï¼ˆç”± Canvas æ³¨å…¥ __firebase_configï¼‰
        if (typeof __firebase_config !== 'undefined') {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
            } catch (error) {
                console.error("Failed to parse Canvas Firebase config:", error);
                firebaseConfig = {};
            }
        } else {
            // --- é‡è¦ï¼šåœ¨æ­¤å¤„ç²˜è´´æ‚¨è‡ªå·±çš„ Firebase é…ç½®å¯¹è±¡ ---
            // å¦‚æœæ‚¨åœ¨ Canvas å¤–éƒ¨è¿è¡Œæ­¤åº”ç”¨ï¼ˆä¾‹å¦‚åœ¨ GitHub Pagesï¼‰ï¼Œæ‚¨å¿…é¡»ç”¨
            // æ‚¨çš„å®é™… Firebase é¡¹ç›®é…ç½®æ›¿æ¢ä¸‹é¢çš„å ä½ç¬¦ã€‚
            // è¯·ä»æ‚¨çš„ Firebase æ§åˆ¶å°è·å–è¿™äº›å€¼ã€‚
            firebaseConfig = {
                apiKey: "AIzaSyD0kALHxst8sqHLLhPNpRyuu-6VOD1tlHo",
                authDomain: "aigame-store.firebaseapp.com",
                projectId: "aigame-store",
                storageBucket: "aigame-store.firebasestorage.app",
                messagingSenderId: "227975426620",
                appId: "1:227975426620:web:cac0a0ad8d8cea87de0939"
            };

            // è­¦å‘Šç”¨æˆ·å¦‚æœä»–ä»¬å¿˜è®°æ›¿æ¢å ä½ç¬¦
            if (firebaseConfig.projectId === "YOUR_PROJECT_ID") {
                console.error("FIREBASE é…ç½®é”™è¯¯ï¼šè¯·å°†æ­¤å¤„çš„å ä½ç¬¦é…ç½®æ›¿æ¢ä¸ºæ‚¨è‡ªå·±çš„ Firebase é¡¹ç›®é…ç½®å‡­æ®ã€‚");
                // ç¡®ä¿åœ¨å¤–éƒ¨è¿è¡Œæ—¶ï¼Œå¦‚æœæœªé…ç½®åˆ™ä½¿ç”¨ç©ºå¯¹è±¡ä»¥é˜²æ­¢å´©æºƒï¼Œä½†ä¼šè®°å½•é”™è¯¯ã€‚
                firebaseConfig = {};
            }
            // --- é…ç½®å—ç»“æŸ ---
        }
        // ç¡®ä¿ firebaseConfig ä¸ä¸ºç©ºï¼Œå³ä½¿åœ¨å¤–éƒ¨æœªé…ç½®æ—¶ã€‚
        if (!firebaseConfig) {
            firebaseConfig = {};
        }

        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase services
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Contexts
        const AuthContext = createContext(null);
        const CurrencyContext = createContext(null);
        const GameContext = createContext(null); // New Game Context

        // =================================================================
        // 2. AUTHENTICATION PROVIDER (AuthProvider)
        // =================================================================

        const AuthProvider = ({ children }) => {
            const [userId, setUserId] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);

            useEffect(() => {
                const initAuth = async () => {
                    try {
                        if (initialAuthToken) {
                            // Sign in using the provided custom token
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            // Fallback to anonymous sign-in for public access
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase sign-in failed:", error);
                    }
                };

                // Listen for auth state changes to get the final UID
                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    if (user) {
                        setUserId(user.uid);
                    } else {
                        // If sign-in fails, use a random ID as fallback
                        setUserId(crypto.randomUUID());
                    }
                    setIsAuthReady(true);
                });

                initAuth();
                return () => unsubscribe();
            }, []);

            // Use createElement instead of JSX
            return e(
                AuthContext.Provider,
                { value: { userId, db, isAuthReady } },
                children
            );
        };

        // =================================================================
        // 3. CURRENCY AND INVENTORY MANAGEMENT (CurrencyProvider)
        // =================================================================

        const AD_LIMIT_PER_DAY = 5;
        const COIN_PER_AD = 10;
        const INITIAL_BALANCE = 100;

        const CurrencyProvider = ({ children }) => {
            const { userId, db, isAuthReady } = useContext(AuthContext);
            const [balance, setBalance] = useState(0);
            const [inventory, setInventory] = useState({});
            const [adsWatchedToday, setAdsWatchedToday] = useState(0);
            const [loading, setLoading] = useState(true);

            // Firestore Document Reference Path function
            const getProfileRef = useCallback((id) => {
                if (!db || !id) return null;
                // Private Data Path: /artifacts/{appId}/users/{userId}/data/profile
                return doc(db, 'artifacts', appId, 'users', id, 'data', 'profile');
            }, [db]);

            // Real-time data synchronization and initialization
            useEffect(() => {
                if (!isAuthReady || !userId) return;

                const profileRef = getProfileRef(userId);
                if (!profileRef) return;

                // Real-time listener
                const unsubscribe = onSnapshot(profileRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        const today = new Date().toDateString();
                        const lastAd = new Date(data.lastAdDate || 0).toDateString();

                        // Daily ad reset logic
                        let currentAdsWatched = data.adsWatchedToday || 0;
                        if (lastAd !== today) {
                            currentAdsWatched = 0; // Reset count for a new day
                        }

                        setBalance(data.balance || 0);
                        setInventory(data.inventory || {});
                        setAdsWatchedToday(currentAdsWatched);
                    } else {
                        // Initialize data if document doesn't exist
                        setBalance(INITIAL_BALANCE);
                        setInventory({});
                        setAdsWatchedToday(0);

                        // Create the initial document
                        setDoc(profileRef, {
                            balance: INITIAL_BALANCE,
                            inventory: {},
                            lastAdDate: new Date(0).toISOString(),
                            adsWatchedToday: 0,
                        }, { merge: true }).catch(err => console.error("Failed to create initial data:", err));
                    }
                    setLoading(false);
                }, (error) => {
                    console.error("Firestore listener failed:", error);
                    setLoading(false);
                });

                return () => unsubscribe();
            }, [isAuthReady, userId, getProfileRef]);

            // Function to watch ad and get coins (with daily limit)
            const watchAd = async () => {
                if (!userId || adsWatchedToday >= AD_LIMIT_PER_DAY) {
                    alert("ä»Šæ—¥å¹¿å‘Šæ¬¡æ•°å·²è¾¾ä¸Šé™ï¼Œè¯·æ˜å¤©å†è¯•ï¼");
                    return false;
                }

                const profileRef = getProfileRef(userId);
                if (!profileRef) return false;

                console.log("Simulating ad playback...");
                await new Promise(resolve => setTimeout(resolve, 1500));

                try {
                    await runTransaction(db, async (transaction) => {
                        const docSnap = await transaction.get(profileRef);
                        if (!docSnap.exists()) throw new Error("ç”¨æˆ·æ•°æ®ä¸å­˜åœ¨");

                        const data = docSnap.data();
                        const today = new Date().toDateString();
                        const lastAd = new Date(data.lastAdDate || 0).toDateString();

                        let newAdsWatched = data.adsWatchedToday || 0;
                        if (lastAd !== today) newAdsWatched = 0;

                        if (newAdsWatched >= AD_LIMIT_PER_DAY) throw new Error("å·²è¶…è¿‡ä»Šæ—¥é™åˆ¶");

                        transaction.update(profileRef, {
                            balance: (data.balance || 0) + COIN_PER_AD,
                            adsWatchedToday: newAdsWatched + 1,
                            lastAdDate: new Date().toISOString(),
                        });
                    });
                    alert(`æ­å–œï¼è·å¾— ${COIN_PER_AD} è™šæ‹Ÿå¸å¥–åŠ±ï¼`);
                    return true;
                } catch (e) {
                    console.error("Ad transaction failed:", e);
                    alert(`å¥–åŠ±å‘æ”¾å¤±è´¥: ${e.message || e}`);
                    return false;
                }
            };

            // Function to buy coins (simulated real-money transaction)
            const buyCoins = async (amount, realCost) => {
                if (!userId) return alert("è¯·å…ˆç™»å½•ã€‚");
                const profileRef = getProfileRef(userId);
                if (!profileRef) return false;

                console.log(`Simulating payment: Buying ${amount} coins for Â¥ ${realCost}...`);
                await new Promise(resolve => setTimeout(resolve, 1000));

                try {
                    await runTransaction(db, async (transaction) => {
                        const docSnap = await transaction.get(profileRef);
                        if (!docSnap.exists()) throw new Error("ç”¨æˆ·æ•°æ®ä¸å­˜åœ¨");

                        const currentBalance = docSnap.data().balance || 0;

                        transaction.update(profileRef, {
                            balance: currentBalance + amount,
                        });
                    });

                    alert(`è´­ä¹°æˆåŠŸï¼è·å¾— ${amount} è™šæ‹Ÿå¸ï¼`);
                    return true;
                } catch (e) {
                    console.error("Coin purchase failed:", e);
                    alert("è´­ä¹°å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚");
                    return false;
                }
            };

            // Function to buy an item using virtual currency
            const buyItem = async (itemId, cost) => {
                if (!userId) return alert("è¯·å…ˆç™»å½•ã€‚");
                const profileRef = getProfileRef(userId);
                if (!profileRef) return false;

                try {
                    await runTransaction(db, async (transaction) => {
                        const docSnap = await transaction.get(profileRef);
                        if (!docSnap.exists()) throw new Error("ç”¨æˆ·æ•°æ®ä¸å­˜åœ¨");

                        const currentBalance = docSnap.data().balance || 0;
                        if (currentBalance < cost) throw new Error("ä½™é¢ä¸è¶³");

                        // Update balance and inventory
                        const newInventory = { ...docSnap.data().inventory };
                        newInventory[itemId] = (newInventory[itemId] || 0) + 1;

                        transaction.update(profileRef, {
                            balance: currentBalance - cost,
                            inventory: newInventory,
                        });
                    });

                    if (cost > 0) {
                        alert(`è´­ä¹°æˆåŠŸï¼è·å¾—é“å…·: ${itemId}`);
                    }
                    return true;
                } catch (e) {
                    console.error("Item purchase failed:", e);
                    alert(`æ“ä½œå¤±è´¥: ${e.message || e}`);
                    return false;
                }
            };

            // Function to consume an item
            const useItem = async (itemId) => {
                if (!userId) return alert("è¯·å…ˆç™»å½•ã€‚");
                const profileRef = getProfileRef(userId);
                if (!profileRef) return false;

                try {
                    await runTransaction(db, async (transaction) => {
                        const docSnap = await transaction.get(profileRef);
                        if (!docSnap.exists()) throw new Error("ç”¨æˆ·æ•°æ®ä¸å­˜åœ¨");

                        const currentInventory = docSnap.data().inventory || {};
                        if ((currentInventory[itemId] || 0) <= 0) throw new Error("åº“å­˜ä¸è¶³");

                        // Decrement inventory
                        const newInventory = { ...currentInventory };
                        newInventory[itemId] = newInventory[itemId] - 1;

                        transaction.update(profileRef, {
                            inventory: newInventory,
                        });
                    });
                    return true;
                } catch (e) {
                    console.error("Item consumption failed:", e);
                    alert(`æ¶ˆè€—å¤±è´¥: ${e.message || e}`);
                    return false;
                }
            }

            const contextValue = {
                balance,
                inventory,
                watchAd,
                buyCoins,
                buyItem,
                useItem,
                adsWatchedToday,
                AD_LIMIT_PER_DAY,
                loading,
                userId,
            };

            // Use createElement instead of JSX
            return e(
                CurrencyContext.Provider,
                { value: contextValue },
                children
            );
        };

        // Hook to use currency system
        const useCurrency = () => useContext(CurrencyContext);

        // =================================================================
        // 4. GAME STRUCTURE AND REGISTRY
        // =================================================================

        // 4.1 Neon Snake Game Component
        const NeonSnakeGame = ({ useItem }) => {
            const { inventory } = useCurrency();
            const isBoosted = inventory['speed_boost'] > 0;

            // Game Constants
            const BOARD_SIZE = 20;
            const INITIAL_SPEED = 100; // milliseconds per move
            const SPEED_BOOST_BONUS = 50; // faster if used speed boost

            // Game State
            const [snake, setSnake] = useState([{ x: 10, y: 10 }]);
            const [food, setFood] = useState({ x: 5, y: 5 });
            const [direction, setDirection] = useState({ x: 1, y: 0 });
            const [running, setRunning] = useState(false);
            const [score, setScore] = useState(0);
            const [gameOver, setGameOver] = useState(false);
            const [isItemActive, setIsItemActive] = useState(false);

            const gameSpeed = INITIAL_SPEED - (isItemActive ? SPEED_BOOST_BONUS : 0);
            const intervalRef = useRef(null);

            // Simple 2D Vector equality check
            const checkCollision = (p1, p2) => p1.x === p2.x && p1.y === p2.y;

            const generateFood = useCallback((currentSnake) => {
                let newFood;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * BOARD_SIZE),
                        y: Math.floor(Math.random() * BOARD_SIZE)
                    };
                } while (currentSnake.some(segment => checkCollision(segment, newFood)));
                return newFood;
            }, []);

            const moveSnake = useCallback(() => {
                if (!running || gameOver) return;

                setSnake(prevSnake => {
                    const head = prevSnake[0];
                    const newHead = { x: head.x + direction.x, y: head.y + direction.y };

                    // Check boundaries & self-collision
                    if (newHead.x < 0 || newHead.x >= BOARD_SIZE || newHead.y < 0 || newHead.y >= BOARD_SIZE ||
                        prevSnake.slice(1).some(segment => checkCollision(segment, newHead))) {
                        setGameOver(true);
                        return prevSnake;
                    }

                    // Check food collision
                    if (checkCollision(newHead, food)) {
                        setScore(s => s + 10);
                        setFood(generateFood([...prevSnake, newHead]));
                        return [newHead, ...prevSnake];
                    } else {
                        return [newHead, ...prevSnake.slice(0, -1)];
                    }
                });
            }, [running, gameOver, direction, food, generateFood]);

            // Set up game interval
            useEffect(() => {
                if (running && !gameOver) {
                    if (intervalRef.current) clearInterval(intervalRef.current);
                    intervalRef.current = setInterval(moveSnake, gameSpeed);
                } else if (intervalRef.current) {
                    clearInterval(intervalRef.current);
                }
                return () => {
                    if (intervalRef.current) clearInterval(intervalRef.current);
                };
            }, [running, gameOver, moveSnake, gameSpeed]);

            // Handle keyboard input
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (!running || gameOver) return;
                    switch (e.key) {
                        case 'ArrowUp':
                            if (direction.y === 0) setDirection({ x: 0, y: -1 });
                            break;
                        case 'ArrowDown':
                            if (direction.y === 0) setDirection({ x: 0, y: 1 });
                            break;
                        case 'ArrowLeft':
                            if (direction.x === 0) setDirection({ x: -1, y: 0 });
                            break;
                        case 'ArrowRight':
                            if (direction.x === 0) setDirection({ x: 1, y: 0 });
                            break;
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [running, gameOver, direction]);

            // Reset game state
            const startGame = (useSpeedItem = false) => {
                setSnake([{ x: 10, y: 10 }]);
                setFood(generateFood([{ x: 10, y: 10 }]));
                setDirection({ x: 1, y: 0 });
                setScore(0);
                setGameOver(false);
                setRunning(true);
                setIsItemActive(useSpeedItem);
            };

            // Function to handle item usage from external button
            const handleUseSpeedBoost = async () => {
                if (!isBoosted) {
                    alert("è¯·å…ˆä»å•†åº—è´­ä¹°é€Ÿåº¦è¯æ°´ï¼");
                    return;
                }
                const success = await useItem('speed_boost');
                if (success) {
                    startGame(true);
                    alert("é€Ÿåº¦è¯æ°´å·²æ¶ˆè€—ï¼æ¸¸æˆå°†ä»¥åŠ é€Ÿæ¨¡å¼å¼€å§‹ã€‚");
                }
            };

            const handleStartNormal = () => {
                startGame(false);
            }

            // Render the game board cells
            const renderBoard = () => {
                const cells = [];
                const isSnake = (x, y) => snake.some(segment => checkCollision(segment, { x, y }));
                const isFood = (x, y) => checkCollision({ x, y }, food);

                for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                    const x = i % BOARD_SIZE;
                    const y = Math.floor(i / BOARD_SIZE);
                    let className = '';

                    if (isSnake(x, y)) {
                        className = 'snake-segment';
                    } else if (isFood(x, y)) {
                        className = 'food-item';
                    }

                    cells.push(e('div', { key: i, className: className }));
                }
                return cells;
            };

            const renderControls = () => {
                if (running && !gameOver) {
                    return e('p', { className: 'text-xl text-cyan-400 font-bold' }, `å¾—åˆ†: ${score} - é€Ÿåº¦: ${gameSpeed}ms`);
                } else if (gameOver) {
                    return e('div', { className: 'flex flex-col items-center space-y-3' },
                        e('p', { className: 'text-3xl text-red-500 font-extrabold' }, `æ¸¸æˆç»“æŸï¼æœ€ç»ˆå¾—åˆ†: ${score}`),
                        e('button', {
                            onClick: handleStartNormal,
                            className: 'bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-6 rounded-full transition duration-150 shadow-xl'
                        }, 'é‡æ–°å¼€å§‹ (æ™®é€šæ¨¡å¼)')
                    );
                } else {
                    // Initial state
                    return e('div', { className: 'flex flex-col sm:flex-row gap-4 justify-center' },
                        e('button', {
                            onClick: handleStartNormal,
                            className: 'bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-6 rounded-full transition duration-150 shadow-xl'
                        }, 'å¼€å§‹æ¸¸æˆ (æ™®é€šæ¨¡å¼)'),
                        e('button', {
                            onClick: handleUseSpeedBoost,
                            disabled: !isBoosted,
                            className: `font-bold py-3 px-6 rounded-full transition duration-150 shadow-xl ${isBoosted
                                    ? 'bg-purple-600 hover:bg-purple-500 text-white'
                                    : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                                }`
                        }, isBoosted ? 'ä½¿ç”¨é€Ÿåº¦è¯æ°´å¼€å§‹' : 'è´­ä¹°è¯æ°´ä»¥åŠ é€Ÿ')
                    );
                }
            }

            // Main render function for the game
            return e('div', { className: 'p-6 bg-gray-900 rounded-xl shadow-inner border border-gray-700/50' },
                e('h3', { className: 'text-2xl font-bold mb-4 text-center text-white' }, 'ğŸ® éœ“è™¹è´ªåƒè›‡æ¸¸æˆ'),
                e('p', { className: 'text-center text-sm mb-4 text-gray-400' }, `ä½¿ç”¨é”®ç›˜æ–¹å‘é”®æ§åˆ¶è›‡ç§»åŠ¨ã€‚${isItemActive ? 'ğŸš€åŠ é€Ÿæ¨¡å¼æ¿€æ´»ï¼' : ''}`),
                e('div', { className: 'snake-board' }, renderBoard()),
                e('div', { className: 'mt-6 text-center' }, renderControls())
            );
        };

        // 4.2 Game Registry (The heart of extensibility)
        const GAME_REGISTRY = {
            'lobby': {
                id: 'lobby',
                name: 'æ¸¸æˆå¤§å…',
                description: 'é€‰æ‹©æ‚¨æƒ³ç©çš„æ¸¸æˆ',
                component: null // Special case for lobby
            },
            'snake': {
                id: 'snake',
                name: 'éœ“è™¹è´ªåƒè›‡',
                description: 'ç»å…¸è´ªåƒè›‡ï¼Œæ”¯æŒé€Ÿåº¦è¯æ°´é“å…·ã€‚',
                component: NeonSnakeGame,
                // Game-specific items can be linked here for easy access
                requiredItem: 'speed_boost'
            },
            // Future games can be added here:
            // 'shooter': {
            //     id: 'shooter',
            //     name: 'æ˜Ÿé™…èº²é¿è€…',
            //     description: 'èº²é¿å¤ªç©ºç¢ç‰‡ï¼Œæ”¯æŒæ°¸ä¹…æŠ¤ç›¾ã€‚',
            //     component: ShooterGame,
            //     requiredItem: 'shield'
            // }
        };

        // 4.3 Game Router Component
        const GameRouter = ({ activeGameId, setActiveGameId }) => {
            const { useItem } = useCurrency();

            // Fallback to lobby if ID is invalid
            const gameId = GAME_REGISTRY[activeGameId] ? activeGameId : 'lobby';
            const GameInfo = GAME_REGISTRY[gameId];

            if (gameId === 'lobby') {
                return e(GameLobby, { setActiveGameId });
            }

            // Render the selected Game component, passing necessary props
            return e(GameInfo.component, {
                // All games receive useItem function and a way to return to lobby
                useItem: useItem,
                goToLobby: () => setActiveGameId('lobby'),
            });
        };


        // 4.4 Game Lobby Component (Replaces the old GamePanel)
        const GameLobby = ({ setActiveGameId }) => {
            const { balance, inventory } = useCurrency();

            const games = Object.values(GAME_REGISTRY).filter(g => g.id !== 'lobby');

            // Item Status Info (for the old placeholder items)
            const hasShield = inventory['shield'] > 0;
            const hasSkin = inventory['cosmetic_skin'] > 0;

            // Lobby Top-level Render
            return e('div', { className: 'p-6 bg-gray-800/50 rounded-xl shadow-lg border border-gray-700/50 backdrop-blur-md space-y-6' },
                e('h2', { className: 'text-3xl font-bold mb-4 text-white text-center' }, 'æ¸¸æˆå¤§å… (Game Lobby)'),
                e('div', { className: 'p-4 bg-gray-700 rounded-lg text-xl font-mono text-green-300 text-center' }, `å½“å‰ä½™é¢: ${balance} å¸`),

                // --- æ¸¸æˆåˆ—è¡¨ ---
                e('h3', { className: 'text-2xl font-semibold mt-6 mb-4 text-cyan-400' }, 'é€‰æ‹©ä¸€ä¸ªæ¸¸æˆ'),
                e('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4' },
                    games.map(game => e('div', { key: game.id, className: 'p-4 bg-gray-700/70 rounded-xl border border-gray-600 hover:bg-gray-600 transition cursor-pointer' },
                        e('h4', { className: 'font-semibold text-xl text-white' }, game.name),
                        e('p', { className: 'text-sm text-gray-400 mb-3' }, game.description),
                        e('button', {
                            onClick: () => setActiveGameId(game.id),
                            className: 'mt-2 w-full py-2 rounded bg-indigo-600 hover:bg-indigo-500 text-white font-bold transition'
                        }, 'è¿›å…¥æ¸¸æˆ')
                    )),
                ),

                // --- é“å…·çŠ¶æ€å±•ç¤º (ä½œä¸ºéæ¸¸æˆå†…é“å…·çš„æ¼”ç¤º) ---
                e('h3', { className: 'text-2xl font-semibold mt-8 mb-4 text-yellow-400' }, 'æŒä¹…é“å…·çŠ¶æ€'),
                e('div', { className: 'grid grid-cols-2 gap-4 text-center' },
                    e('div', { className: 'p-4 bg-gray-700/50 rounded-lg border border-gray-600' },
                        e('p', { className: 'text-lg font-semibold' }, 'æ°¸ä¹…æŠ¤ç›¾çŠ¶æ€'),
                        e('p', { className: 'text-xl font-bold mt-2' }, hasShield ? 'ğŸŸ¢ å·²æ‹¥æœ‰' : 'âšª æœªæ‹¥æœ‰'),
                        e('p', { className: 'text-sm text-gray-400' }, `åº“å­˜: ${inventory['shield'] || 0}`)
                    ),
                    e('div', { className: 'p-4 bg-gray-700/50 rounded-lg border border-gray-600' },
                        e('p', { className: 'text-lg font-semibold' }, 'é£èˆ¹çš®è‚¤çŠ¶æ€'),
                        e('p', { className: 'text-xl font-bold mt-2' }, hasSkin ? 'ğŸŒŸ å·²æ‹¥æœ‰' : 'âšª æœªæ‹¥æœ‰'),
                        e('p', { className: 'text-sm text-gray-400' }, `åº“å­˜: ${inventory['cosmetic_skin'] || 0}`)
                    )
                )
            );
        }

        // 4.5 Store Component (Remains largely the same)
        const Store = () => {
            const { buyItem, inventory, adsWatchedToday, AD_LIMIT_PER_DAY, watchAd, buyCoins } = useCurrency();

            const shopItems = [
                { id: 'shield', name: 'æ°¸ä¹…æŠ¤ç›¾', cost: 150, description: 'åœ¨æ˜Ÿé™…èº²é¿ä¸­æ‹¥æœ‰é¢å¤–ä¸€æ¬¡æŠ¤ç›¾' },
                { id: 'speed_boost', name: 'é€Ÿåº¦è¯æ°´', cost: 50, description: 'è´ªåƒè›‡æ¸¸æˆå¼€å±€é€Ÿåº¦æé«˜' },
                { id: 'cosmetic_skin', name: 'é£èˆ¹çš®è‚¤', cost: 200, description: 'è§£é”é£èˆ¹çš„ç‚«é…·çš®è‚¤' },
            ];

            const coinPacks = [
                { amount: 50, cost: 0.99 },
                { amount: 120, cost: 1.99 },
                { amount: 300, cost: 4.99 },
            ];

            // Render Coin Packs Section
            const renderCoinPacks = () => e('section', null,
                e('h3', { className: 'text-xl font-semibold mb-3 text-indigo-400' }, 'ğŸ’° è´­ä¹°è™šæ‹Ÿå¸ (RMB)'),
                e('div', { className: 'space-y-3' },
                    coinPacks.map(pack => e('button', {
                        key: pack.amount,
                        onClick: () => buyCoins(pack.amount, pack.cost),
                        className: 'w-full flex justify-between items-center p-3 rounded-lg bg-indigo-600 hover:bg-indigo-500 transition duration-150 shadow-md text-white font-medium'
                    },
                        e('span', null, `${pack.amount} è™šæ‹Ÿå¸`),
                        e('span', { className: 'text-sm bg-indigo-700 py-1 px-3 rounded-full' }, `Â¥ ${pack.cost}`)
                    ))
                )
            );

            // Render Ad Section
            const renderAdSection = () => e('section', null,
                e('h3', { className: 'text-xl font-semibold mb-3 text-pink-400' }, 'ğŸ“º å…è´¹è·å– (çœ‹å¹¿å‘Š)'),
                e('div', { className: 'space-y-3' },
                    e('p', { className: 'text-sm text-gray-400' }, `ä»Šæ—¥å·²çœ‹: ${adsWatchedToday} / ${AD_LIMIT_PER_DAY} æ¬¡`),
                    e('button', {
                        onClick: watchAd,
                        disabled: adsWatchedToday >= AD_LIMIT_PER_DAY,
                        className: `mt-1 w-full p-4 rounded-lg transition duration-150 font-bold ${adsWatchedToday >= AD_LIMIT_PER_DAY
                                ? 'bg-gray-600 text-gray-400 cursor-not-allowed'
                                : 'bg-pink-600 hover:bg-pink-500 text-white shadow-lg'
                            }`
                    }, adsWatchedToday >= AD_LIMIT_PER_DAY ? 'ä»Šæ—¥é¢åº¦å·²ç”¨å®Œ' : `è§‚çœ‹å¹¿å‘Š (å¾— ${COIN_PER_AD} å¸)`),
                    e('p', { className: 'text-xs text-gray-500 mt-2' }, 'ï¼ˆæ­¤æ“ä½œå°†æ›´æ–°æ‚¨çš„ Firestore è´¦æˆ·æ•°æ®ï¼‰')
                )
            );

            // Render Items Section
            const renderShopItems = () => e('div', { className: 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4' },
                shopItems.map(item => e('div', { key: item.id, className: 'p-4 bg-gray-700/70 rounded-lg border border-gray-600' },
                    e('h4', { className: 'font-semibold text-lg text-cyan-400' }, item.name),
                    e('p', { className: 'text-sm text-gray-400 mb-3' }, item.description),
                    e('div', { className: 'flex justify-between items-center' },
                        e('span', { className: 'text-base font-bold text-yellow-300' }, `${item.cost} å¸`),
                        e('button', {
                            onClick: () => buyItem(item.id, item.cost),
                            className: 'bg-cyan-600 text-white px-4 py-2 rounded-lg hover:bg-cyan-500 transition duration-150 text-sm'
                        }, `è´­ä¹° (åº“å­˜: ${inventory[item.id] || 0})`)
                    )
                ))
            );

            // Store Top-level Render
            return e('div', { className: 'p-6 bg-gray-800/50 rounded-xl shadow-lg border border-gray-700/50 backdrop-blur-md' },
                e('h2', { className: 'text-2xl font-bold mb-4 text-white' }, 'è™šæ‹Ÿè´§å¸å•†åº—'),
                e('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-6' },
                    renderCoinPacks(),
                    renderAdSection()
                ),
                e('h3', { className: 'text-2xl font-bold mt-8 mb-4 text-white' }, 'è´­ä¹°æ¸¸æˆé“å…·'),
                renderShopItems()
            );
        };


        // 4.6 Main Application Component (App)
        const App = () => {
            const { isAuthReady } = useContext(AuthContext);
            const { loading, userId } = useCurrency();

            // State to manage which game component to display (The Router State)
            const [activeGameId, setActiveGameId] = useState('lobby');

            if (!isAuthReady || loading) {
                return e('div', { className: 'min-h-screen flex items-center justify-center bg-gray-900 text-white' },
                    e('div', { className: 'animate-pulse' }, 'æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...')
                );
            }

            // Header Render
            const renderHeader = () => e('header', { className: 'text-center mb-8' },
                e('h1', { className: 'text-4xl font-extrabold text-white mb-2' }, 'AI æ¸¸æˆç›ˆåˆ©ç³»ç»Ÿæ¼”ç¤º'),
                e('p', { className: 'text-sm text-gray-500' },
                    'å½“å‰ç”¨æˆ· ID: ',
                    e('span', { className: 'text-yellow-400 break-all' }, userId),
                    e('button', {
                        onClick: () => setActiveGameId('lobby'),
                        className: 'ml-4 text-sm text-indigo-400 hover:text-indigo-300 transition'
                    }, '(è¿”å›å¤§å…)')
                )
            );

            // Footer Render
            const renderFooter = () => e('footer', { className: 'text-center text-gray-600 pt-8' },
                e('p', null, 'æ•°æ®å®æ—¶åŒæ­¥äº Firestore æ•°æ®åº“ã€‚')
            );

            // App Top-level Render
            return e('div', { className: 'min-h-screen bg-gray-900 p-8' },
                renderHeader(),
                e('main', { className: 'max-w-4xl mx-auto space-y-8' },
                    e(Store, null),
                    // Game Router renders the selected game or the lobby
                    e(GameRouter, { activeGameId, setActiveGameId })
                ),
                renderFooter()
            );
        };

        // Ensure React application is rendered after the page loads
        window.onload = function () {
            const rootElement = document.getElementById('root');
            if (!rootElement) {
                console.error("æ— æ³•æ‰¾åˆ° #root å…ƒç´ ã€‚");
                return;
            }

            // Use the new React 18 API to render the app wrapped in providers
            createRoot(rootElement).render(
                e(AuthProvider, null,
                    e(CurrencyProvider, null,
                        e(App, null)
                    )
                )
            );
        }
    </script>
</body>
</html>